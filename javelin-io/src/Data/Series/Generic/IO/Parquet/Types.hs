-- This file was autogenerated by the process_thrift_definitions.sh script
{-# LANGUAGE TypeFamilies, DeriveGeneric, TypeApplications, OverloadedStrings #-}
{-# OPTIONS_GHC -w #-}

module Data.Series.Generic.IO.Parquet.Types where

import qualified Prelude
import qualified Control.Applicative
import qualified Control.Exception
import qualified Pinch
import qualified Pinch.Server
import qualified Pinch.Internal.RPC
import qualified Data.Text
import qualified Data.ByteString
import qualified Data.Int
import qualified Data.Vector
import qualified Data.HashMap.Strict
import qualified Data.HashSet
import qualified GHC.Generics
import qualified Data.Hashable
import  Data.Vector.Instances ()

data Type
  = BOOLEAN
  | INT32
  | INT64
  | INT96
  | FLOAT
  | DOUBLE
  | BYTE_ARRAY
  | FIXED_LEN_BYTE_ARRAY
  deriving (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic, Prelude.Show, Prelude.Bounded)

instance Pinch.Pinchable Type where
  type (Tag Type) = Pinch.TEnum

  pinch BOOLEAN = Pinch.pinch ((0 :: Data.Int.Int32))
  pinch INT32 = Pinch.pinch ((1 :: Data.Int.Int32))
  pinch INT64 = Pinch.pinch ((2 :: Data.Int.Int32))
  pinch INT96 = Pinch.pinch ((3 :: Data.Int.Int32))
  pinch FLOAT = Pinch.pinch ((4 :: Data.Int.Int32))
  pinch DOUBLE = Pinch.pinch ((5 :: Data.Int.Int32))
  pinch BYTE_ARRAY = Pinch.pinch ((6 :: Data.Int.Int32))
  pinch FIXED_LEN_BYTE_ARRAY = Pinch.pinch ((7 :: Data.Int.Int32))

  unpinch v = do
    val <- Pinch.unpinch (v)
    case (val :: Data.Int.Int32) of
      0 -> Prelude.pure (BOOLEAN)
      1 -> Prelude.pure (INT32)
      2 -> Prelude.pure (INT64)
      3 -> Prelude.pure (INT96)
      4 -> Prelude.pure (FLOAT)
      5 -> Prelude.pure (DOUBLE)
      6 -> Prelude.pure (BYTE_ARRAY)
      7 -> Prelude.pure (FIXED_LEN_BYTE_ARRAY)
      _ -> Prelude.fail (("Unknown value for type Type: " Prelude.<> Prelude.show (val)))


instance Prelude.Enum Type where
  fromEnum BOOLEAN = 0
  fromEnum INT32 = 1
  fromEnum INT64 = 2
  fromEnum INT96 = 3
  fromEnum FLOAT = 4
  fromEnum DOUBLE = 5
  fromEnum BYTE_ARRAY = 6
  fromEnum FIXED_LEN_BYTE_ARRAY = 7

  toEnum 0 = BOOLEAN
  toEnum 1 = INT32
  toEnum 2 = INT64
  toEnum 3 = INT96
  toEnum 4 = FLOAT
  toEnum 5 = DOUBLE
  toEnum 6 = BYTE_ARRAY
  toEnum 7 = FIXED_LEN_BYTE_ARRAY
  toEnum _ = Prelude.error ("Unknown value for enum Type.")


instance Data.Hashable.Hashable Type where

data ConvertedType
  = UTF8
  | MAP
  | MAP_KEY_VALUE
  | LIST
  | ENUM
  | DECIMAL
  | DATE
  | TIME_MILLIS
  | TIME_MICROS
  | TIMESTAMP_MILLIS
  | TIMESTAMP_MICROS
  | UINT_8
  | UINT_16
  | UINT_32
  | UINT_64
  | INT_8
  | INT_16
  | INT_32
  | INT_64
  | JSON
  | BSON
  | INTERVAL
  deriving (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic, Prelude.Show, Prelude.Bounded)

instance Pinch.Pinchable ConvertedType where
  type (Tag ConvertedType) = Pinch.TEnum

  pinch UTF8 = Pinch.pinch ((0 :: Data.Int.Int32))
  pinch MAP = Pinch.pinch ((1 :: Data.Int.Int32))
  pinch MAP_KEY_VALUE = Pinch.pinch ((2 :: Data.Int.Int32))
  pinch LIST = Pinch.pinch ((3 :: Data.Int.Int32))
  pinch ENUM = Pinch.pinch ((4 :: Data.Int.Int32))
  pinch DECIMAL = Pinch.pinch ((5 :: Data.Int.Int32))
  pinch DATE = Pinch.pinch ((6 :: Data.Int.Int32))
  pinch TIME_MILLIS = Pinch.pinch ((7 :: Data.Int.Int32))
  pinch TIME_MICROS = Pinch.pinch ((8 :: Data.Int.Int32))
  pinch TIMESTAMP_MILLIS = Pinch.pinch ((9 :: Data.Int.Int32))
  pinch TIMESTAMP_MICROS = Pinch.pinch ((10 :: Data.Int.Int32))
  pinch UINT_8 = Pinch.pinch ((11 :: Data.Int.Int32))
  pinch UINT_16 = Pinch.pinch ((12 :: Data.Int.Int32))
  pinch UINT_32 = Pinch.pinch ((13 :: Data.Int.Int32))
  pinch UINT_64 = Pinch.pinch ((14 :: Data.Int.Int32))
  pinch INT_8 = Pinch.pinch ((15 :: Data.Int.Int32))
  pinch INT_16 = Pinch.pinch ((16 :: Data.Int.Int32))
  pinch INT_32 = Pinch.pinch ((17 :: Data.Int.Int32))
  pinch INT_64 = Pinch.pinch ((18 :: Data.Int.Int32))
  pinch JSON = Pinch.pinch ((19 :: Data.Int.Int32))
  pinch BSON = Pinch.pinch ((20 :: Data.Int.Int32))
  pinch INTERVAL = Pinch.pinch ((21 :: Data.Int.Int32))

  unpinch v = do
    val <- Pinch.unpinch (v)
    case (val :: Data.Int.Int32) of
      0 -> Prelude.pure (UTF8)
      1 -> Prelude.pure (MAP)
      2 -> Prelude.pure (MAP_KEY_VALUE)
      3 -> Prelude.pure (LIST)
      4 -> Prelude.pure (ENUM)
      5 -> Prelude.pure (DECIMAL)
      6 -> Prelude.pure (DATE)
      7 -> Prelude.pure (TIME_MILLIS)
      8 -> Prelude.pure (TIME_MICROS)
      9 -> Prelude.pure (TIMESTAMP_MILLIS)
      10 -> Prelude.pure (TIMESTAMP_MICROS)
      11 -> Prelude.pure (UINT_8)
      12 -> Prelude.pure (UINT_16)
      13 -> Prelude.pure (UINT_32)
      14 -> Prelude.pure (UINT_64)
      15 -> Prelude.pure (INT_8)
      16 -> Prelude.pure (INT_16)
      17 -> Prelude.pure (INT_32)
      18 -> Prelude.pure (INT_64)
      19 -> Prelude.pure (JSON)
      20 -> Prelude.pure (BSON)
      21 -> Prelude.pure (INTERVAL)
      _ -> Prelude.fail (("Unknown value for type ConvertedType: " Prelude.<> Prelude.show (val)))


instance Prelude.Enum ConvertedType where
  fromEnum UTF8 = 0
  fromEnum MAP = 1
  fromEnum MAP_KEY_VALUE = 2
  fromEnum LIST = 3
  fromEnum ENUM = 4
  fromEnum DECIMAL = 5
  fromEnum DATE = 6
  fromEnum TIME_MILLIS = 7
  fromEnum TIME_MICROS = 8
  fromEnum TIMESTAMP_MILLIS = 9
  fromEnum TIMESTAMP_MICROS = 10
  fromEnum UINT_8 = 11
  fromEnum UINT_16 = 12
  fromEnum UINT_32 = 13
  fromEnum UINT_64 = 14
  fromEnum INT_8 = 15
  fromEnum INT_16 = 16
  fromEnum INT_32 = 17
  fromEnum INT_64 = 18
  fromEnum JSON = 19
  fromEnum BSON = 20
  fromEnum INTERVAL = 21

  toEnum 0 = UTF8
  toEnum 1 = MAP
  toEnum 2 = MAP_KEY_VALUE
  toEnum 3 = LIST
  toEnum 4 = ENUM
  toEnum 5 = DECIMAL
  toEnum 6 = DATE
  toEnum 7 = TIME_MILLIS
  toEnum 8 = TIME_MICROS
  toEnum 9 = TIMESTAMP_MILLIS
  toEnum 10 = TIMESTAMP_MICROS
  toEnum 11 = UINT_8
  toEnum 12 = UINT_16
  toEnum 13 = UINT_32
  toEnum 14 = UINT_64
  toEnum 15 = INT_8
  toEnum 16 = INT_16
  toEnum 17 = INT_32
  toEnum 18 = INT_64
  toEnum 19 = JSON
  toEnum 20 = BSON
  toEnum 21 = INTERVAL
  toEnum _ = Prelude.error ("Unknown value for enum ConvertedType.")


instance Data.Hashable.Hashable ConvertedType where

data FieldRepetitionType
  = REQUIRED
  | OPTIONAL
  | REPEATED
  deriving (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic, Prelude.Show, Prelude.Bounded)

instance Pinch.Pinchable FieldRepetitionType where
  type (Tag FieldRepetitionType) = Pinch.TEnum

  pinch REQUIRED = Pinch.pinch ((0 :: Data.Int.Int32))
  pinch OPTIONAL = Pinch.pinch ((1 :: Data.Int.Int32))
  pinch REPEATED = Pinch.pinch ((2 :: Data.Int.Int32))

  unpinch v = do
    val <- Pinch.unpinch (v)
    case (val :: Data.Int.Int32) of
      0 -> Prelude.pure (REQUIRED)
      1 -> Prelude.pure (OPTIONAL)
      2 -> Prelude.pure (REPEATED)
      _ -> Prelude.fail (("Unknown value for type FieldRepetitionType: " Prelude.<> Prelude.show (val)))


instance Prelude.Enum FieldRepetitionType where
  fromEnum REQUIRED = 0
  fromEnum OPTIONAL = 1
  fromEnum REPEATED = 2

  toEnum 0 = REQUIRED
  toEnum 1 = OPTIONAL
  toEnum 2 = REPEATED
  toEnum _ = Prelude.error ("Unknown value for enum FieldRepetitionType.")


instance Data.Hashable.Hashable FieldRepetitionType where

data SizeStatistics
  = SizeStatistics { sizeStatistics_unencoded_byte_array_data_bytes :: (Prelude.Maybe Data.Int.Int64), sizeStatistics_repetition_level_histogram :: (Prelude.Maybe (Data.Vector.Vector Data.Int.Int64)), sizeStatistics_definition_level_histogram :: (Prelude.Maybe (Data.Vector.Vector Data.Int.Int64)) }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable SizeStatistics where
  type (Tag SizeStatistics) = Pinch.TStruct

  pinch (SizeStatistics sizeStatistics_unencoded_byte_array_data_bytes sizeStatistics_repetition_level_histogram sizeStatistics_definition_level_histogram) = Pinch.struct ([ (1 Pinch.?= sizeStatistics_unencoded_byte_array_data_bytes), (2 Pinch.?= sizeStatistics_repetition_level_histogram), (3 Pinch.?= sizeStatistics_definition_level_histogram) ])

  unpinch value = (((Prelude.pure (SizeStatistics) Prelude.<*> (value Pinch..:? 1)) Prelude.<*> (value Pinch..:? 2)) Prelude.<*> (value Pinch..:? 3))


instance Data.Hashable.Hashable SizeStatistics where

data Statistics
  = Statistics { statistics_max :: (Prelude.Maybe Data.ByteString.ByteString), statistics_min :: (Prelude.Maybe Data.ByteString.ByteString), statistics_null_count :: (Prelude.Maybe Data.Int.Int64), statistics_distinct_count :: (Prelude.Maybe Data.Int.Int64), statistics_max_value :: (Prelude.Maybe Data.ByteString.ByteString), statistics_min_value :: (Prelude.Maybe Data.ByteString.ByteString), statistics_is_max_value_exact :: (Prelude.Maybe Prelude.Bool), statistics_is_min_value_exact :: (Prelude.Maybe Prelude.Bool) }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable Statistics where
  type (Tag Statistics) = Pinch.TStruct

  pinch (Statistics statistics_max statistics_min statistics_null_count statistics_distinct_count statistics_max_value statistics_min_value statistics_is_max_value_exact statistics_is_min_value_exact) = Pinch.struct ([ (1 Pinch.?= statistics_max), (2 Pinch.?= statistics_min), (3 Pinch.?= statistics_null_count), (4 Pinch.?= statistics_distinct_count), (5 Pinch.?= statistics_max_value), (6 Pinch.?= statistics_min_value), (7 Pinch.?= statistics_is_max_value_exact), (8 Pinch.?= statistics_is_min_value_exact) ])

  unpinch value = ((((((((Prelude.pure (Statistics) Prelude.<*> (value Pinch..:? 1)) Prelude.<*> (value Pinch..:? 2)) Prelude.<*> (value Pinch..:? 3)) Prelude.<*> (value Pinch..:? 4)) Prelude.<*> (value Pinch..:? 5)) Prelude.<*> (value Pinch..:? 6)) Prelude.<*> (value Pinch..:? 7)) Prelude.<*> (value Pinch..:? 8))


instance Data.Hashable.Hashable Statistics where

data StringType
  = StringType {  }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable StringType where
  type (Tag StringType) = Pinch.TStruct

  pinch StringType = Pinch.struct ([  ])

  unpinch value = Prelude.pure (StringType)


instance Data.Hashable.Hashable StringType where

data UUIDType
  = UUIDType {  }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable UUIDType where
  type (Tag UUIDType) = Pinch.TStruct

  pinch UUIDType = Pinch.struct ([  ])

  unpinch value = Prelude.pure (UUIDType)


instance Data.Hashable.Hashable UUIDType where

data MapType
  = MapType {  }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable MapType where
  type (Tag MapType) = Pinch.TStruct

  pinch MapType = Pinch.struct ([  ])

  unpinch value = Prelude.pure (MapType)


instance Data.Hashable.Hashable MapType where

data ListType
  = ListType {  }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable ListType where
  type (Tag ListType) = Pinch.TStruct

  pinch ListType = Pinch.struct ([  ])

  unpinch value = Prelude.pure (ListType)


instance Data.Hashable.Hashable ListType where

data EnumType
  = EnumType {  }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable EnumType where
  type (Tag EnumType) = Pinch.TStruct

  pinch EnumType = Pinch.struct ([  ])

  unpinch value = Prelude.pure (EnumType)


instance Data.Hashable.Hashable EnumType where

data DateType
  = DateType {  }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable DateType where
  type (Tag DateType) = Pinch.TStruct

  pinch DateType = Pinch.struct ([  ])

  unpinch value = Prelude.pure (DateType)


instance Data.Hashable.Hashable DateType where

data Float16Type
  = Float16Type {  }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable Float16Type where
  type (Tag Float16Type) = Pinch.TStruct

  pinch Float16Type = Pinch.struct ([  ])

  unpinch value = Prelude.pure (Float16Type)


instance Data.Hashable.Hashable Float16Type where

data NullType
  = NullType {  }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable NullType where
  type (Tag NullType) = Pinch.TStruct

  pinch NullType = Pinch.struct ([  ])

  unpinch value = Prelude.pure (NullType)


instance Data.Hashable.Hashable NullType where

data DecimalType
  = DecimalType { decimalType_scale :: Data.Int.Int32, decimalType_precision :: Data.Int.Int32 }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable DecimalType where
  type (Tag DecimalType) = Pinch.TStruct

  pinch (DecimalType decimalType_scale decimalType_precision) = Pinch.struct ([ (1 Pinch..= decimalType_scale), (2 Pinch..= decimalType_precision) ])

  unpinch value = ((Prelude.pure (DecimalType) Prelude.<*> (value Pinch..: 1)) Prelude.<*> (value Pinch..: 2))


instance Data.Hashable.Hashable DecimalType where

data MilliSeconds
  = MilliSeconds {  }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable MilliSeconds where
  type (Tag MilliSeconds) = Pinch.TStruct

  pinch MilliSeconds = Pinch.struct ([  ])

  unpinch value = Prelude.pure (MilliSeconds)


instance Data.Hashable.Hashable MilliSeconds where

data MicroSeconds
  = MicroSeconds {  }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable MicroSeconds where
  type (Tag MicroSeconds) = Pinch.TStruct

  pinch MicroSeconds = Pinch.struct ([  ])

  unpinch value = Prelude.pure (MicroSeconds)


instance Data.Hashable.Hashable MicroSeconds where

data NanoSeconds
  = NanoSeconds {  }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable NanoSeconds where
  type (Tag NanoSeconds) = Pinch.TStruct

  pinch NanoSeconds = Pinch.struct ([  ])

  unpinch value = Prelude.pure (NanoSeconds)


instance Data.Hashable.Hashable NanoSeconds where

data TimeUnit
  = TimeUnit_MILLIS MilliSeconds
  | TimeUnit_MICROS MicroSeconds
  | TimeUnit_NANOS NanoSeconds
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable TimeUnit where
  type (Tag TimeUnit) = Pinch.TUnion

  pinch (TimeUnit_MILLIS x) = Pinch.union (1) (x)
  pinch (TimeUnit_MICROS x) = Pinch.union (2) (x)
  pinch (TimeUnit_NANOS x) = Pinch.union (3) (x)

  unpinch v = (((Control.Applicative.empty Control.Applicative.<|> (TimeUnit_MILLIS Prelude.<$> (v Pinch..: 1))) Control.Applicative.<|> (TimeUnit_MICROS Prelude.<$> (v Pinch..: 2))) Control.Applicative.<|> (TimeUnit_NANOS Prelude.<$> (v Pinch..: 3)))


instance Data.Hashable.Hashable TimeUnit where

data TimestampType
  = TimestampType { timestampType_isAdjustedToUTC :: Prelude.Bool, timestampType_unit :: TimeUnit }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable TimestampType where
  type (Tag TimestampType) = Pinch.TStruct

  pinch (TimestampType timestampType_isAdjustedToUTC timestampType_unit) = Pinch.struct ([ (1 Pinch..= timestampType_isAdjustedToUTC), (2 Pinch..= timestampType_unit) ])

  unpinch value = ((Prelude.pure (TimestampType) Prelude.<*> (value Pinch..: 1)) Prelude.<*> (value Pinch..: 2))


instance Data.Hashable.Hashable TimestampType where

data TimeType
  = TimeType { timeType_isAdjustedToUTC :: Prelude.Bool, timeType_unit :: TimeUnit }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable TimeType where
  type (Tag TimeType) = Pinch.TStruct

  pinch (TimeType timeType_isAdjustedToUTC timeType_unit) = Pinch.struct ([ (1 Pinch..= timeType_isAdjustedToUTC), (2 Pinch..= timeType_unit) ])

  unpinch value = ((Prelude.pure (TimeType) Prelude.<*> (value Pinch..: 1)) Prelude.<*> (value Pinch..: 2))


instance Data.Hashable.Hashable TimeType where

data IntType
  = IntType { intType_bitWidth :: Data.Int.Int8, intType_isSigned :: Prelude.Bool }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable IntType where
  type (Tag IntType) = Pinch.TStruct

  pinch (IntType intType_bitWidth intType_isSigned) = Pinch.struct ([ (1 Pinch..= intType_bitWidth), (2 Pinch..= intType_isSigned) ])

  unpinch value = ((Prelude.pure (IntType) Prelude.<*> (value Pinch..: 1)) Prelude.<*> (value Pinch..: 2))


instance Data.Hashable.Hashable IntType where

data JsonType
  = JsonType {  }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable JsonType where
  type (Tag JsonType) = Pinch.TStruct

  pinch JsonType = Pinch.struct ([  ])

  unpinch value = Prelude.pure (JsonType)


instance Data.Hashable.Hashable JsonType where

data BsonType
  = BsonType {  }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable BsonType where
  type (Tag BsonType) = Pinch.TStruct

  pinch BsonType = Pinch.struct ([  ])

  unpinch value = Prelude.pure (BsonType)


instance Data.Hashable.Hashable BsonType where

data LogicalType
  = LogicalType_STRING StringType
  | LogicalType_MAP MapType
  | LogicalType_LIST ListType
  | LogicalType_ENUM EnumType
  | LogicalType_DECIMAL DecimalType
  | LogicalType_DATE DateType
  | LogicalType_TIME TimeType
  | LogicalType_TIMESTAMP TimestampType
  | LogicalType_INTEGER IntType
  | LogicalType_UNKNOWN NullType
  | LogicalType_JSON JsonType
  | LogicalType_BSON BsonType
  | LogicalType_UUID UUIDType
  | LogicalType_FLOAT16 Float16Type
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable LogicalType where
  type (Tag LogicalType) = Pinch.TUnion

  pinch (LogicalType_STRING x) = Pinch.union (1) (x)
  pinch (LogicalType_MAP x) = Pinch.union (2) (x)
  pinch (LogicalType_LIST x) = Pinch.union (3) (x)
  pinch (LogicalType_ENUM x) = Pinch.union (4) (x)
  pinch (LogicalType_DECIMAL x) = Pinch.union (5) (x)
  pinch (LogicalType_DATE x) = Pinch.union (6) (x)
  pinch (LogicalType_TIME x) = Pinch.union (7) (x)
  pinch (LogicalType_TIMESTAMP x) = Pinch.union (8) (x)
  pinch (LogicalType_INTEGER x) = Pinch.union (10) (x)
  pinch (LogicalType_UNKNOWN x) = Pinch.union (11) (x)
  pinch (LogicalType_JSON x) = Pinch.union (12) (x)
  pinch (LogicalType_BSON x) = Pinch.union (13) (x)
  pinch (LogicalType_UUID x) = Pinch.union (14) (x)
  pinch (LogicalType_FLOAT16 x) = Pinch.union (15) (x)

  unpinch v = ((((((((((((((Control.Applicative.empty Control.Applicative.<|> (LogicalType_STRING Prelude.<$> (v Pinch..: 1))) Control.Applicative.<|> (LogicalType_MAP Prelude.<$> (v Pinch..: 2))) Control.Applicative.<|> (LogicalType_LIST Prelude.<$> (v Pinch..: 3))) Control.Applicative.<|> (LogicalType_ENUM Prelude.<$> (v Pinch..: 4))) Control.Applicative.<|> (LogicalType_DECIMAL Prelude.<$> (v Pinch..: 5))) Control.Applicative.<|> (LogicalType_DATE Prelude.<$> (v Pinch..: 6))) Control.Applicative.<|> (LogicalType_TIME Prelude.<$> (v Pinch..: 7))) Control.Applicative.<|> (LogicalType_TIMESTAMP Prelude.<$> (v Pinch..: 8))) Control.Applicative.<|> (LogicalType_INTEGER Prelude.<$> (v Pinch..: 10))) Control.Applicative.<|> (LogicalType_UNKNOWN Prelude.<$> (v Pinch..: 11))) Control.Applicative.<|> (LogicalType_JSON Prelude.<$> (v Pinch..: 12))) Control.Applicative.<|> (LogicalType_BSON Prelude.<$> (v Pinch..: 13))) Control.Applicative.<|> (LogicalType_UUID Prelude.<$> (v Pinch..: 14))) Control.Applicative.<|> (LogicalType_FLOAT16 Prelude.<$> (v Pinch..: 15)))


instance Data.Hashable.Hashable LogicalType where

data SchemaElement
  = SchemaElement { schemaElement_type :: (Prelude.Maybe Type), schemaElement_type_length :: (Prelude.Maybe Data.Int.Int32), schemaElement_repetition_type :: (Prelude.Maybe FieldRepetitionType), schemaElement_name :: Data.Text.Text, schemaElement_num_children :: (Prelude.Maybe Data.Int.Int32), schemaElement_converted_type :: (Prelude.Maybe ConvertedType), schemaElement_scale :: (Prelude.Maybe Data.Int.Int32), schemaElement_precision :: (Prelude.Maybe Data.Int.Int32), schemaElement_field_id :: (Prelude.Maybe Data.Int.Int32), schemaElement_logicalType :: (Prelude.Maybe LogicalType) }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable SchemaElement where
  type (Tag SchemaElement) = Pinch.TStruct

  pinch (SchemaElement schemaElement_type schemaElement_type_length schemaElement_repetition_type schemaElement_name schemaElement_num_children schemaElement_converted_type schemaElement_scale schemaElement_precision schemaElement_field_id schemaElement_logicalType) = Pinch.struct ([ (1 Pinch.?= schemaElement_type), (2 Pinch.?= schemaElement_type_length), (3 Pinch.?= schemaElement_repetition_type), (4 Pinch..= schemaElement_name), (5 Pinch.?= schemaElement_num_children), (6 Pinch.?= schemaElement_converted_type), (7 Pinch.?= schemaElement_scale), (8 Pinch.?= schemaElement_precision), (9 Pinch.?= schemaElement_field_id), (10 Pinch.?= schemaElement_logicalType) ])

  unpinch value = ((((((((((Prelude.pure (SchemaElement) Prelude.<*> (value Pinch..:? 1)) Prelude.<*> (value Pinch..:? 2)) Prelude.<*> (value Pinch..:? 3)) Prelude.<*> (value Pinch..: 4)) Prelude.<*> (value Pinch..:? 5)) Prelude.<*> (value Pinch..:? 6)) Prelude.<*> (value Pinch..:? 7)) Prelude.<*> (value Pinch..:? 8)) Prelude.<*> (value Pinch..:? 9)) Prelude.<*> (value Pinch..:? 10))


instance Data.Hashable.Hashable SchemaElement where

data Encoding
  = PLAIN
  | PLAIN_DICTIONARY
  | RLE
  | BIT_PACKED
  | DELTA_BINARY_PACKED
  | DELTA_LENGTH_BYTE_ARRAY
  | DELTA_BYTE_ARRAY
  | RLE_DICTIONARY
  | BYTE_STREAM_SPLIT
  deriving (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic, Prelude.Show, Prelude.Bounded)

instance Pinch.Pinchable Encoding where
  type (Tag Encoding) = Pinch.TEnum

  pinch PLAIN = Pinch.pinch ((0 :: Data.Int.Int32))
  pinch PLAIN_DICTIONARY = Pinch.pinch ((2 :: Data.Int.Int32))
  pinch RLE = Pinch.pinch ((3 :: Data.Int.Int32))
  pinch BIT_PACKED = Pinch.pinch ((4 :: Data.Int.Int32))
  pinch DELTA_BINARY_PACKED = Pinch.pinch ((5 :: Data.Int.Int32))
  pinch DELTA_LENGTH_BYTE_ARRAY = Pinch.pinch ((6 :: Data.Int.Int32))
  pinch DELTA_BYTE_ARRAY = Pinch.pinch ((7 :: Data.Int.Int32))
  pinch RLE_DICTIONARY = Pinch.pinch ((8 :: Data.Int.Int32))
  pinch BYTE_STREAM_SPLIT = Pinch.pinch ((9 :: Data.Int.Int32))

  unpinch v = do
    val <- Pinch.unpinch (v)
    case (val :: Data.Int.Int32) of
      0 -> Prelude.pure (PLAIN)
      2 -> Prelude.pure (PLAIN_DICTIONARY)
      3 -> Prelude.pure (RLE)
      4 -> Prelude.pure (BIT_PACKED)
      5 -> Prelude.pure (DELTA_BINARY_PACKED)
      6 -> Prelude.pure (DELTA_LENGTH_BYTE_ARRAY)
      7 -> Prelude.pure (DELTA_BYTE_ARRAY)
      8 -> Prelude.pure (RLE_DICTIONARY)
      9 -> Prelude.pure (BYTE_STREAM_SPLIT)
      _ -> Prelude.fail (("Unknown value for type Encoding: " Prelude.<> Prelude.show (val)))


instance Prelude.Enum Encoding where
  fromEnum PLAIN = 0
  fromEnum PLAIN_DICTIONARY = 2
  fromEnum RLE = 3
  fromEnum BIT_PACKED = 4
  fromEnum DELTA_BINARY_PACKED = 5
  fromEnum DELTA_LENGTH_BYTE_ARRAY = 6
  fromEnum DELTA_BYTE_ARRAY = 7
  fromEnum RLE_DICTIONARY = 8
  fromEnum BYTE_STREAM_SPLIT = 9

  toEnum 0 = PLAIN
  toEnum 2 = PLAIN_DICTIONARY
  toEnum 3 = RLE
  toEnum 4 = BIT_PACKED
  toEnum 5 = DELTA_BINARY_PACKED
  toEnum 6 = DELTA_LENGTH_BYTE_ARRAY
  toEnum 7 = DELTA_BYTE_ARRAY
  toEnum 8 = RLE_DICTIONARY
  toEnum 9 = BYTE_STREAM_SPLIT
  toEnum _ = Prelude.error ("Unknown value for enum Encoding.")


instance Data.Hashable.Hashable Encoding where

data CompressionCodec
  = UNCOMPRESSED
  | SNAPPY
  | GZIP
  | LZO
  | BROTLI
  | LZ4
  | ZSTD
  | LZ4_RAW
  deriving (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic, Prelude.Show, Prelude.Bounded)

instance Pinch.Pinchable CompressionCodec where
  type (Tag CompressionCodec) = Pinch.TEnum

  pinch UNCOMPRESSED = Pinch.pinch ((0 :: Data.Int.Int32))
  pinch SNAPPY = Pinch.pinch ((1 :: Data.Int.Int32))
  pinch GZIP = Pinch.pinch ((2 :: Data.Int.Int32))
  pinch LZO = Pinch.pinch ((3 :: Data.Int.Int32))
  pinch BROTLI = Pinch.pinch ((4 :: Data.Int.Int32))
  pinch LZ4 = Pinch.pinch ((5 :: Data.Int.Int32))
  pinch ZSTD = Pinch.pinch ((6 :: Data.Int.Int32))
  pinch LZ4_RAW = Pinch.pinch ((7 :: Data.Int.Int32))

  unpinch v = do
    val <- Pinch.unpinch (v)
    case (val :: Data.Int.Int32) of
      0 -> Prelude.pure (UNCOMPRESSED)
      1 -> Prelude.pure (SNAPPY)
      2 -> Prelude.pure (GZIP)
      3 -> Prelude.pure (LZO)
      4 -> Prelude.pure (BROTLI)
      5 -> Prelude.pure (LZ4)
      6 -> Prelude.pure (ZSTD)
      7 -> Prelude.pure (LZ4_RAW)
      _ -> Prelude.fail (("Unknown value for type CompressionCodec: " Prelude.<> Prelude.show (val)))


instance Prelude.Enum CompressionCodec where
  fromEnum UNCOMPRESSED = 0
  fromEnum SNAPPY = 1
  fromEnum GZIP = 2
  fromEnum LZO = 3
  fromEnum BROTLI = 4
  fromEnum LZ4 = 5
  fromEnum ZSTD = 6
  fromEnum LZ4_RAW = 7

  toEnum 0 = UNCOMPRESSED
  toEnum 1 = SNAPPY
  toEnum 2 = GZIP
  toEnum 3 = LZO
  toEnum 4 = BROTLI
  toEnum 5 = LZ4
  toEnum 6 = ZSTD
  toEnum 7 = LZ4_RAW
  toEnum _ = Prelude.error ("Unknown value for enum CompressionCodec.")


instance Data.Hashable.Hashable CompressionCodec where

data PageType
  = DATA_PAGE
  | INDEX_PAGE
  | DICTIONARY_PAGE
  | DATA_PAGE_V2
  deriving (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic, Prelude.Show, Prelude.Bounded)

instance Pinch.Pinchable PageType where
  type (Tag PageType) = Pinch.TEnum

  pinch DATA_PAGE = Pinch.pinch ((0 :: Data.Int.Int32))
  pinch INDEX_PAGE = Pinch.pinch ((1 :: Data.Int.Int32))
  pinch DICTIONARY_PAGE = Pinch.pinch ((2 :: Data.Int.Int32))
  pinch DATA_PAGE_V2 = Pinch.pinch ((3 :: Data.Int.Int32))

  unpinch v = do
    val <- Pinch.unpinch (v)
    case (val :: Data.Int.Int32) of
      0 -> Prelude.pure (DATA_PAGE)
      1 -> Prelude.pure (INDEX_PAGE)
      2 -> Prelude.pure (DICTIONARY_PAGE)
      3 -> Prelude.pure (DATA_PAGE_V2)
      _ -> Prelude.fail (("Unknown value for type PageType: " Prelude.<> Prelude.show (val)))


instance Prelude.Enum PageType where
  fromEnum DATA_PAGE = 0
  fromEnum INDEX_PAGE = 1
  fromEnum DICTIONARY_PAGE = 2
  fromEnum DATA_PAGE_V2 = 3

  toEnum 0 = DATA_PAGE
  toEnum 1 = INDEX_PAGE
  toEnum 2 = DICTIONARY_PAGE
  toEnum 3 = DATA_PAGE_V2
  toEnum _ = Prelude.error ("Unknown value for enum PageType.")


instance Data.Hashable.Hashable PageType where

data BoundaryOrder
  = UNORDERED
  | ASCENDING
  | DESCENDING
  deriving (Prelude.Eq, Prelude.Ord, GHC.Generics.Generic, Prelude.Show, Prelude.Bounded)

instance Pinch.Pinchable BoundaryOrder where
  type (Tag BoundaryOrder) = Pinch.TEnum

  pinch UNORDERED = Pinch.pinch ((0 :: Data.Int.Int32))
  pinch ASCENDING = Pinch.pinch ((1 :: Data.Int.Int32))
  pinch DESCENDING = Pinch.pinch ((2 :: Data.Int.Int32))

  unpinch v = do
    val <- Pinch.unpinch (v)
    case (val :: Data.Int.Int32) of
      0 -> Prelude.pure (UNORDERED)
      1 -> Prelude.pure (ASCENDING)
      2 -> Prelude.pure (DESCENDING)
      _ -> Prelude.fail (("Unknown value for type BoundaryOrder: " Prelude.<> Prelude.show (val)))


instance Prelude.Enum BoundaryOrder where
  fromEnum UNORDERED = 0
  fromEnum ASCENDING = 1
  fromEnum DESCENDING = 2

  toEnum 0 = UNORDERED
  toEnum 1 = ASCENDING
  toEnum 2 = DESCENDING
  toEnum _ = Prelude.error ("Unknown value for enum BoundaryOrder.")


instance Data.Hashable.Hashable BoundaryOrder where

data DataPageHeader
  = DataPageHeader { dataPageHeader_num_values :: Data.Int.Int32, dataPageHeader_encoding :: Encoding, dataPageHeader_definition_level_encoding :: Encoding, dataPageHeader_repetition_level_encoding :: Encoding, dataPageHeader_statistics :: (Prelude.Maybe Statistics) }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable DataPageHeader where
  type (Tag DataPageHeader) = Pinch.TStruct

  pinch (DataPageHeader dataPageHeader_num_values dataPageHeader_encoding dataPageHeader_definition_level_encoding dataPageHeader_repetition_level_encoding dataPageHeader_statistics) = Pinch.struct ([ (1 Pinch..= dataPageHeader_num_values), (2 Pinch..= dataPageHeader_encoding), (3 Pinch..= dataPageHeader_definition_level_encoding), (4 Pinch..= dataPageHeader_repetition_level_encoding), (5 Pinch.?= dataPageHeader_statistics) ])

  unpinch value = (((((Prelude.pure (DataPageHeader) Prelude.<*> (value Pinch..: 1)) Prelude.<*> (value Pinch..: 2)) Prelude.<*> (value Pinch..: 3)) Prelude.<*> (value Pinch..: 4)) Prelude.<*> (value Pinch..:? 5))


instance Data.Hashable.Hashable DataPageHeader where

data IndexPageHeader
  = IndexPageHeader {  }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable IndexPageHeader where
  type (Tag IndexPageHeader) = Pinch.TStruct

  pinch IndexPageHeader = Pinch.struct ([  ])

  unpinch value = Prelude.pure (IndexPageHeader)


instance Data.Hashable.Hashable IndexPageHeader where

data DictionaryPageHeader
  = DictionaryPageHeader { dictionaryPageHeader_num_values :: Data.Int.Int32, dictionaryPageHeader_encoding :: Encoding, dictionaryPageHeader_is_sorted :: (Prelude.Maybe Prelude.Bool) }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable DictionaryPageHeader where
  type (Tag DictionaryPageHeader) = Pinch.TStruct

  pinch (DictionaryPageHeader dictionaryPageHeader_num_values dictionaryPageHeader_encoding dictionaryPageHeader_is_sorted) = Pinch.struct ([ (1 Pinch..= dictionaryPageHeader_num_values), (2 Pinch..= dictionaryPageHeader_encoding), (3 Pinch.?= dictionaryPageHeader_is_sorted) ])

  unpinch value = (((Prelude.pure (DictionaryPageHeader) Prelude.<*> (value Pinch..: 1)) Prelude.<*> (value Pinch..: 2)) Prelude.<*> (value Pinch..:? 3))


instance Data.Hashable.Hashable DictionaryPageHeader where

data DataPageHeaderV2
  = DataPageHeaderV2 { dataPageHeaderV2_num_values :: Data.Int.Int32, dataPageHeaderV2_num_nulls :: Data.Int.Int32, dataPageHeaderV2_num_rows :: Data.Int.Int32, dataPageHeaderV2_encoding :: Encoding, dataPageHeaderV2_definition_levels_byte_length :: Data.Int.Int32, dataPageHeaderV2_repetition_levels_byte_length :: Data.Int.Int32, dataPageHeaderV2_is_compressed :: (Prelude.Maybe Prelude.Bool), dataPageHeaderV2_statistics :: (Prelude.Maybe Statistics) }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable DataPageHeaderV2 where
  type (Tag DataPageHeaderV2) = Pinch.TStruct

  pinch (DataPageHeaderV2 dataPageHeaderV2_num_values dataPageHeaderV2_num_nulls dataPageHeaderV2_num_rows dataPageHeaderV2_encoding dataPageHeaderV2_definition_levels_byte_length dataPageHeaderV2_repetition_levels_byte_length dataPageHeaderV2_is_compressed dataPageHeaderV2_statistics) = Pinch.struct ([ (1 Pinch..= dataPageHeaderV2_num_values), (2 Pinch..= dataPageHeaderV2_num_nulls), (3 Pinch..= dataPageHeaderV2_num_rows), (4 Pinch..= dataPageHeaderV2_encoding), (5 Pinch..= dataPageHeaderV2_definition_levels_byte_length), (6 Pinch..= dataPageHeaderV2_repetition_levels_byte_length), (7 Pinch.?= dataPageHeaderV2_is_compressed), (8 Pinch.?= dataPageHeaderV2_statistics) ])

  unpinch value = ((((((((Prelude.pure (DataPageHeaderV2) Prelude.<*> (value Pinch..: 1)) Prelude.<*> (value Pinch..: 2)) Prelude.<*> (value Pinch..: 3)) Prelude.<*> (value Pinch..: 4)) Prelude.<*> (value Pinch..: 5)) Prelude.<*> (value Pinch..: 6)) Prelude.<*> (value Pinch..:? 7)) Prelude.<*> (value Pinch..:? 8))


instance Data.Hashable.Hashable DataPageHeaderV2 where

data SplitBlockAlgorithm
  = SplitBlockAlgorithm {  }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable SplitBlockAlgorithm where
  type (Tag SplitBlockAlgorithm) = Pinch.TStruct

  pinch SplitBlockAlgorithm = Pinch.struct ([  ])

  unpinch value = Prelude.pure (SplitBlockAlgorithm)


instance Data.Hashable.Hashable SplitBlockAlgorithm where

data BloomFilterAlgorithm
  = BloomFilterAlgorithm_BLOCK SplitBlockAlgorithm
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable BloomFilterAlgorithm where
  type (Tag BloomFilterAlgorithm) = Pinch.TUnion

  pinch (BloomFilterAlgorithm_BLOCK x) = Pinch.union (1) (x)

  unpinch v = (Control.Applicative.empty Control.Applicative.<|> (BloomFilterAlgorithm_BLOCK Prelude.<$> (v Pinch..: 1)))


instance Data.Hashable.Hashable BloomFilterAlgorithm where

data XxHash
  = XxHash {  }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable XxHash where
  type (Tag XxHash) = Pinch.TStruct

  pinch XxHash = Pinch.struct ([  ])

  unpinch value = Prelude.pure (XxHash)


instance Data.Hashable.Hashable XxHash where

data BloomFilterHash
  = BloomFilterHash_XXHASH XxHash
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable BloomFilterHash where
  type (Tag BloomFilterHash) = Pinch.TUnion

  pinch (BloomFilterHash_XXHASH x) = Pinch.union (1) (x)

  unpinch v = (Control.Applicative.empty Control.Applicative.<|> (BloomFilterHash_XXHASH Prelude.<$> (v Pinch..: 1)))


instance Data.Hashable.Hashable BloomFilterHash where

data Uncompressed
  = Uncompressed {  }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable Uncompressed where
  type (Tag Uncompressed) = Pinch.TStruct

  pinch Uncompressed = Pinch.struct ([  ])

  unpinch value = Prelude.pure (Uncompressed)


instance Data.Hashable.Hashable Uncompressed where

data BloomFilterCompression
  = BloomFilterCompression_UNCOMPRESSED Uncompressed
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable BloomFilterCompression where
  type (Tag BloomFilterCompression) = Pinch.TUnion

  pinch (BloomFilterCompression_UNCOMPRESSED x) = Pinch.union (1) (x)

  unpinch v = (Control.Applicative.empty Control.Applicative.<|> (BloomFilterCompression_UNCOMPRESSED Prelude.<$> (v Pinch..: 1)))


instance Data.Hashable.Hashable BloomFilterCompression where

data BloomFilterHeader
  = BloomFilterHeader { bloomFilterHeader_numBytes :: Data.Int.Int32, bloomFilterHeader_algorithm :: BloomFilterAlgorithm, bloomFilterHeader_hash :: BloomFilterHash, bloomFilterHeader_compression :: BloomFilterCompression }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable BloomFilterHeader where
  type (Tag BloomFilterHeader) = Pinch.TStruct

  pinch (BloomFilterHeader bloomFilterHeader_numBytes bloomFilterHeader_algorithm bloomFilterHeader_hash bloomFilterHeader_compression) = Pinch.struct ([ (1 Pinch..= bloomFilterHeader_numBytes), (2 Pinch..= bloomFilterHeader_algorithm), (3 Pinch..= bloomFilterHeader_hash), (4 Pinch..= bloomFilterHeader_compression) ])

  unpinch value = ((((Prelude.pure (BloomFilterHeader) Prelude.<*> (value Pinch..: 1)) Prelude.<*> (value Pinch..: 2)) Prelude.<*> (value Pinch..: 3)) Prelude.<*> (value Pinch..: 4))


instance Data.Hashable.Hashable BloomFilterHeader where

data PageHeader
  = PageHeader { pageHeader_type :: PageType, pageHeader_uncompressed_page_size :: Data.Int.Int32, pageHeader_compressed_page_size :: Data.Int.Int32, pageHeader_crc :: (Prelude.Maybe Data.Int.Int32), pageHeader_data_page_header :: (Prelude.Maybe DataPageHeader), pageHeader_index_page_header :: (Prelude.Maybe IndexPageHeader), pageHeader_dictionary_page_header :: (Prelude.Maybe DictionaryPageHeader), pageHeader_data_page_header_v2 :: (Prelude.Maybe DataPageHeaderV2) }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable PageHeader where
  type (Tag PageHeader) = Pinch.TStruct

  pinch (PageHeader pageHeader_type pageHeader_uncompressed_page_size pageHeader_compressed_page_size pageHeader_crc pageHeader_data_page_header pageHeader_index_page_header pageHeader_dictionary_page_header pageHeader_data_page_header_v2) = Pinch.struct ([ (1 Pinch..= pageHeader_type), (2 Pinch..= pageHeader_uncompressed_page_size), (3 Pinch..= pageHeader_compressed_page_size), (4 Pinch.?= pageHeader_crc), (5 Pinch.?= pageHeader_data_page_header), (6 Pinch.?= pageHeader_index_page_header), (7 Pinch.?= pageHeader_dictionary_page_header), (8 Pinch.?= pageHeader_data_page_header_v2) ])

  unpinch value = ((((((((Prelude.pure (PageHeader) Prelude.<*> (value Pinch..: 1)) Prelude.<*> (value Pinch..: 2)) Prelude.<*> (value Pinch..: 3)) Prelude.<*> (value Pinch..:? 4)) Prelude.<*> (value Pinch..:? 5)) Prelude.<*> (value Pinch..:? 6)) Prelude.<*> (value Pinch..:? 7)) Prelude.<*> (value Pinch..:? 8))


instance Data.Hashable.Hashable PageHeader where

data KeyValue
  = KeyValue { keyValue_key :: Data.Text.Text, keyValue_value :: (Prelude.Maybe Data.Text.Text) }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable KeyValue where
  type (Tag KeyValue) = Pinch.TStruct

  pinch (KeyValue keyValue_key keyValue_value) = Pinch.struct ([ (1 Pinch..= keyValue_key), (2 Pinch.?= keyValue_value) ])

  unpinch value = ((Prelude.pure (KeyValue) Prelude.<*> (value Pinch..: 1)) Prelude.<*> (value Pinch..:? 2))


instance Data.Hashable.Hashable KeyValue where

data SortingColumn
  = SortingColumn { sortingColumn_column_idx :: Data.Int.Int32, sortingColumn_descending :: Prelude.Bool, sortingColumn_nulls_first :: Prelude.Bool }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable SortingColumn where
  type (Tag SortingColumn) = Pinch.TStruct

  pinch (SortingColumn sortingColumn_column_idx sortingColumn_descending sortingColumn_nulls_first) = Pinch.struct ([ (1 Pinch..= sortingColumn_column_idx), (2 Pinch..= sortingColumn_descending), (3 Pinch..= sortingColumn_nulls_first) ])

  unpinch value = (((Prelude.pure (SortingColumn) Prelude.<*> (value Pinch..: 1)) Prelude.<*> (value Pinch..: 2)) Prelude.<*> (value Pinch..: 3))


instance Data.Hashable.Hashable SortingColumn where

data PageEncodingStats
  = PageEncodingStats { pageEncodingStats_page_type :: PageType, pageEncodingStats_encoding :: Encoding, pageEncodingStats_count :: Data.Int.Int32 }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable PageEncodingStats where
  type (Tag PageEncodingStats) = Pinch.TStruct

  pinch (PageEncodingStats pageEncodingStats_page_type pageEncodingStats_encoding pageEncodingStats_count) = Pinch.struct ([ (1 Pinch..= pageEncodingStats_page_type), (2 Pinch..= pageEncodingStats_encoding), (3 Pinch..= pageEncodingStats_count) ])

  unpinch value = (((Prelude.pure (PageEncodingStats) Prelude.<*> (value Pinch..: 1)) Prelude.<*> (value Pinch..: 2)) Prelude.<*> (value Pinch..: 3))


instance Data.Hashable.Hashable PageEncodingStats where

data ColumnMetaData
  = ColumnMetaData { columnMetaData_type :: Type, columnMetaData_encodings :: (Data.Vector.Vector Encoding), columnMetaData_path_in_schema :: (Data.Vector.Vector Data.Text.Text), columnMetaData_codec :: CompressionCodec, columnMetaData_num_values :: Data.Int.Int64, columnMetaData_total_uncompressed_size :: Data.Int.Int64, columnMetaData_total_compressed_size :: Data.Int.Int64, columnMetaData_key_value_metadata :: (Prelude.Maybe (Data.Vector.Vector KeyValue)), columnMetaData_data_page_offset :: Data.Int.Int64, columnMetaData_index_page_offset :: (Prelude.Maybe Data.Int.Int64), columnMetaData_dictionary_page_offset :: (Prelude.Maybe Data.Int.Int64), columnMetaData_statistics :: (Prelude.Maybe Statistics), columnMetaData_encoding_stats :: (Prelude.Maybe (Data.Vector.Vector PageEncodingStats)), columnMetaData_bloom_filter_offset :: (Prelude.Maybe Data.Int.Int64), columnMetaData_bloom_filter_length :: (Prelude.Maybe Data.Int.Int32), columnMetaData_size_statistics :: (Prelude.Maybe SizeStatistics) }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable ColumnMetaData where
  type (Tag ColumnMetaData) = Pinch.TStruct

  pinch (ColumnMetaData columnMetaData_type columnMetaData_encodings columnMetaData_path_in_schema columnMetaData_codec columnMetaData_num_values columnMetaData_total_uncompressed_size columnMetaData_total_compressed_size columnMetaData_key_value_metadata columnMetaData_data_page_offset columnMetaData_index_page_offset columnMetaData_dictionary_page_offset columnMetaData_statistics columnMetaData_encoding_stats columnMetaData_bloom_filter_offset columnMetaData_bloom_filter_length columnMetaData_size_statistics) = Pinch.struct ([ (1 Pinch..= columnMetaData_type), (2 Pinch..= columnMetaData_encodings), (3 Pinch..= columnMetaData_path_in_schema), (4 Pinch..= columnMetaData_codec), (5 Pinch..= columnMetaData_num_values), (6 Pinch..= columnMetaData_total_uncompressed_size), (7 Pinch..= columnMetaData_total_compressed_size), (8 Pinch.?= columnMetaData_key_value_metadata), (9 Pinch..= columnMetaData_data_page_offset), (10 Pinch.?= columnMetaData_index_page_offset), (11 Pinch.?= columnMetaData_dictionary_page_offset), (12 Pinch.?= columnMetaData_statistics), (13 Pinch.?= columnMetaData_encoding_stats), (14 Pinch.?= columnMetaData_bloom_filter_offset), (15 Pinch.?= columnMetaData_bloom_filter_length), (16 Pinch.?= columnMetaData_size_statistics) ])

  unpinch value = ((((((((((((((((Prelude.pure (ColumnMetaData) Prelude.<*> (value Pinch..: 1)) Prelude.<*> (value Pinch..: 2)) Prelude.<*> (value Pinch..: 3)) Prelude.<*> (value Pinch..: 4)) Prelude.<*> (value Pinch..: 5)) Prelude.<*> (value Pinch..: 6)) Prelude.<*> (value Pinch..: 7)) Prelude.<*> (value Pinch..:? 8)) Prelude.<*> (value Pinch..: 9)) Prelude.<*> (value Pinch..:? 10)) Prelude.<*> (value Pinch..:? 11)) Prelude.<*> (value Pinch..:? 12)) Prelude.<*> (value Pinch..:? 13)) Prelude.<*> (value Pinch..:? 14)) Prelude.<*> (value Pinch..:? 15)) Prelude.<*> (value Pinch..:? 16))


instance Data.Hashable.Hashable ColumnMetaData where

data EncryptionWithFooterKey
  = EncryptionWithFooterKey {  }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable EncryptionWithFooterKey where
  type (Tag EncryptionWithFooterKey) = Pinch.TStruct

  pinch EncryptionWithFooterKey = Pinch.struct ([  ])

  unpinch value = Prelude.pure (EncryptionWithFooterKey)


instance Data.Hashable.Hashable EncryptionWithFooterKey where

data EncryptionWithColumnKey
  = EncryptionWithColumnKey { encryptionWithColumnKey_path_in_schema :: (Data.Vector.Vector Data.Text.Text), encryptionWithColumnKey_key_metadata :: (Prelude.Maybe Data.ByteString.ByteString) }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable EncryptionWithColumnKey where
  type (Tag EncryptionWithColumnKey) = Pinch.TStruct

  pinch (EncryptionWithColumnKey encryptionWithColumnKey_path_in_schema encryptionWithColumnKey_key_metadata) = Pinch.struct ([ (1 Pinch..= encryptionWithColumnKey_path_in_schema), (2 Pinch.?= encryptionWithColumnKey_key_metadata) ])

  unpinch value = ((Prelude.pure (EncryptionWithColumnKey) Prelude.<*> (value Pinch..: 1)) Prelude.<*> (value Pinch..:? 2))


instance Data.Hashable.Hashable EncryptionWithColumnKey where

data ColumnCryptoMetaData
  = ColumnCryptoMetaData_ENCRYPTION_WITH_FOOTER_KEY EncryptionWithFooterKey
  | ColumnCryptoMetaData_ENCRYPTION_WITH_COLUMN_KEY EncryptionWithColumnKey
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable ColumnCryptoMetaData where
  type (Tag ColumnCryptoMetaData) = Pinch.TUnion

  pinch (ColumnCryptoMetaData_ENCRYPTION_WITH_FOOTER_KEY x) = Pinch.union (1) (x)
  pinch (ColumnCryptoMetaData_ENCRYPTION_WITH_COLUMN_KEY x) = Pinch.union (2) (x)

  unpinch v = ((Control.Applicative.empty Control.Applicative.<|> (ColumnCryptoMetaData_ENCRYPTION_WITH_FOOTER_KEY Prelude.<$> (v Pinch..: 1))) Control.Applicative.<|> (ColumnCryptoMetaData_ENCRYPTION_WITH_COLUMN_KEY Prelude.<$> (v Pinch..: 2)))


instance Data.Hashable.Hashable ColumnCryptoMetaData where

data ColumnChunk
  = ColumnChunk { columnChunk_file_path :: (Prelude.Maybe Data.Text.Text), columnChunk_file_offset :: Data.Int.Int64, columnChunk_meta_data :: (Prelude.Maybe ColumnMetaData), columnChunk_offset_index_offset :: (Prelude.Maybe Data.Int.Int64), columnChunk_offset_index_length :: (Prelude.Maybe Data.Int.Int32), columnChunk_column_index_offset :: (Prelude.Maybe Data.Int.Int64), columnChunk_column_index_length :: (Prelude.Maybe Data.Int.Int32), columnChunk_crypto_metadata :: (Prelude.Maybe ColumnCryptoMetaData), columnChunk_encrypted_column_metadata :: (Prelude.Maybe Data.ByteString.ByteString) }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable ColumnChunk where
  type (Tag ColumnChunk) = Pinch.TStruct

  pinch (ColumnChunk columnChunk_file_path columnChunk_file_offset columnChunk_meta_data columnChunk_offset_index_offset columnChunk_offset_index_length columnChunk_column_index_offset columnChunk_column_index_length columnChunk_crypto_metadata columnChunk_encrypted_column_metadata) = Pinch.struct ([ (1 Pinch.?= columnChunk_file_path), (2 Pinch..= columnChunk_file_offset), (3 Pinch.?= columnChunk_meta_data), (4 Pinch.?= columnChunk_offset_index_offset), (5 Pinch.?= columnChunk_offset_index_length), (6 Pinch.?= columnChunk_column_index_offset), (7 Pinch.?= columnChunk_column_index_length), (8 Pinch.?= columnChunk_crypto_metadata), (9 Pinch.?= columnChunk_encrypted_column_metadata) ])

  unpinch value = (((((((((Prelude.pure (ColumnChunk) Prelude.<*> (value Pinch..:? 1)) Prelude.<*> (value Pinch..: 2)) Prelude.<*> (value Pinch..:? 3)) Prelude.<*> (value Pinch..:? 4)) Prelude.<*> (value Pinch..:? 5)) Prelude.<*> (value Pinch..:? 6)) Prelude.<*> (value Pinch..:? 7)) Prelude.<*> (value Pinch..:? 8)) Prelude.<*> (value Pinch..:? 9))


instance Data.Hashable.Hashable ColumnChunk where

data RowGroup
  = RowGroup { rowGroup_columns :: (Data.Vector.Vector ColumnChunk), rowGroup_total_byte_size :: Data.Int.Int64, rowGroup_num_rows :: Data.Int.Int64, rowGroup_sorting_columns :: (Prelude.Maybe (Data.Vector.Vector SortingColumn)), rowGroup_file_offset :: (Prelude.Maybe Data.Int.Int64), rowGroup_total_compressed_size :: (Prelude.Maybe Data.Int.Int64), rowGroup_ordinal :: (Prelude.Maybe Data.Int.Int16) }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable RowGroup where
  type (Tag RowGroup) = Pinch.TStruct

  pinch (RowGroup rowGroup_columns rowGroup_total_byte_size rowGroup_num_rows rowGroup_sorting_columns rowGroup_file_offset rowGroup_total_compressed_size rowGroup_ordinal) = Pinch.struct ([ (1 Pinch..= rowGroup_columns), (2 Pinch..= rowGroup_total_byte_size), (3 Pinch..= rowGroup_num_rows), (4 Pinch.?= rowGroup_sorting_columns), (5 Pinch.?= rowGroup_file_offset), (6 Pinch.?= rowGroup_total_compressed_size), (7 Pinch.?= rowGroup_ordinal) ])

  unpinch value = (((((((Prelude.pure (RowGroup) Prelude.<*> (value Pinch..: 1)) Prelude.<*> (value Pinch..: 2)) Prelude.<*> (value Pinch..: 3)) Prelude.<*> (value Pinch..:? 4)) Prelude.<*> (value Pinch..:? 5)) Prelude.<*> (value Pinch..:? 6)) Prelude.<*> (value Pinch..:? 7))


instance Data.Hashable.Hashable RowGroup where

data TypeDefinedOrder
  = TypeDefinedOrder {  }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable TypeDefinedOrder where
  type (Tag TypeDefinedOrder) = Pinch.TStruct

  pinch TypeDefinedOrder = Pinch.struct ([  ])

  unpinch value = Prelude.pure (TypeDefinedOrder)


instance Data.Hashable.Hashable TypeDefinedOrder where

data ColumnOrder
  = ColumnOrder_TYPE_ORDER TypeDefinedOrder
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable ColumnOrder where
  type (Tag ColumnOrder) = Pinch.TUnion

  pinch (ColumnOrder_TYPE_ORDER x) = Pinch.union (1) (x)

  unpinch v = (Control.Applicative.empty Control.Applicative.<|> (ColumnOrder_TYPE_ORDER Prelude.<$> (v Pinch..: 1)))


instance Data.Hashable.Hashable ColumnOrder where

data PageLocation
  = PageLocation { pageLocation_offset :: Data.Int.Int64, pageLocation_compressed_page_size :: Data.Int.Int32, pageLocation_first_row_index :: Data.Int.Int64 }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable PageLocation where
  type (Tag PageLocation) = Pinch.TStruct

  pinch (PageLocation pageLocation_offset pageLocation_compressed_page_size pageLocation_first_row_index) = Pinch.struct ([ (1 Pinch..= pageLocation_offset), (2 Pinch..= pageLocation_compressed_page_size), (3 Pinch..= pageLocation_first_row_index) ])

  unpinch value = (((Prelude.pure (PageLocation) Prelude.<*> (value Pinch..: 1)) Prelude.<*> (value Pinch..: 2)) Prelude.<*> (value Pinch..: 3))


instance Data.Hashable.Hashable PageLocation where

data OffsetIndex
  = OffsetIndex { offsetIndex_page_locations :: (Data.Vector.Vector PageLocation), offsetIndex_unencoded_byte_array_data_bytes :: (Prelude.Maybe (Data.Vector.Vector Data.Int.Int64)) }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable OffsetIndex where
  type (Tag OffsetIndex) = Pinch.TStruct

  pinch (OffsetIndex offsetIndex_page_locations offsetIndex_unencoded_byte_array_data_bytes) = Pinch.struct ([ (1 Pinch..= offsetIndex_page_locations), (2 Pinch.?= offsetIndex_unencoded_byte_array_data_bytes) ])

  unpinch value = ((Prelude.pure (OffsetIndex) Prelude.<*> (value Pinch..: 1)) Prelude.<*> (value Pinch..:? 2))


instance Data.Hashable.Hashable OffsetIndex where

data ColumnIndex
  = ColumnIndex { columnIndex_null_pages :: (Data.Vector.Vector Prelude.Bool), columnIndex_min_values :: (Data.Vector.Vector Data.ByteString.ByteString), columnIndex_max_values :: (Data.Vector.Vector Data.ByteString.ByteString), columnIndex_boundary_order :: BoundaryOrder, columnIndex_null_counts :: (Prelude.Maybe (Data.Vector.Vector Data.Int.Int64)), columnIndex_repetition_level_histograms :: (Prelude.Maybe (Data.Vector.Vector Data.Int.Int64)), columnIndex_definition_level_histograms :: (Prelude.Maybe (Data.Vector.Vector Data.Int.Int64)) }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable ColumnIndex where
  type (Tag ColumnIndex) = Pinch.TStruct

  pinch (ColumnIndex columnIndex_null_pages columnIndex_min_values columnIndex_max_values columnIndex_boundary_order columnIndex_null_counts columnIndex_repetition_level_histograms columnIndex_definition_level_histograms) = Pinch.struct ([ (1 Pinch..= columnIndex_null_pages), (2 Pinch..= columnIndex_min_values), (3 Pinch..= columnIndex_max_values), (4 Pinch..= columnIndex_boundary_order), (5 Pinch.?= columnIndex_null_counts), (6 Pinch.?= columnIndex_repetition_level_histograms), (7 Pinch.?= columnIndex_definition_level_histograms) ])

  unpinch value = (((((((Prelude.pure (ColumnIndex) Prelude.<*> (value Pinch..: 1)) Prelude.<*> (value Pinch..: 2)) Prelude.<*> (value Pinch..: 3)) Prelude.<*> (value Pinch..: 4)) Prelude.<*> (value Pinch..:? 5)) Prelude.<*> (value Pinch..:? 6)) Prelude.<*> (value Pinch..:? 7))


instance Data.Hashable.Hashable ColumnIndex where

data AesGcmV1
  = AesGcmV1 { aesGcmV1_aad_prefix :: (Prelude.Maybe Data.ByteString.ByteString), aesGcmV1_aad_file_unique :: (Prelude.Maybe Data.ByteString.ByteString), aesGcmV1_supply_aad_prefix :: (Prelude.Maybe Prelude.Bool) }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable AesGcmV1 where
  type (Tag AesGcmV1) = Pinch.TStruct

  pinch (AesGcmV1 aesGcmV1_aad_prefix aesGcmV1_aad_file_unique aesGcmV1_supply_aad_prefix) = Pinch.struct ([ (1 Pinch.?= aesGcmV1_aad_prefix), (2 Pinch.?= aesGcmV1_aad_file_unique), (3 Pinch.?= aesGcmV1_supply_aad_prefix) ])

  unpinch value = (((Prelude.pure (AesGcmV1) Prelude.<*> (value Pinch..:? 1)) Prelude.<*> (value Pinch..:? 2)) Prelude.<*> (value Pinch..:? 3))


instance Data.Hashable.Hashable AesGcmV1 where

data AesGcmCtrV1
  = AesGcmCtrV1 { aesGcmCtrV1_aad_prefix :: (Prelude.Maybe Data.ByteString.ByteString), aesGcmCtrV1_aad_file_unique :: (Prelude.Maybe Data.ByteString.ByteString), aesGcmCtrV1_supply_aad_prefix :: (Prelude.Maybe Prelude.Bool) }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable AesGcmCtrV1 where
  type (Tag AesGcmCtrV1) = Pinch.TStruct

  pinch (AesGcmCtrV1 aesGcmCtrV1_aad_prefix aesGcmCtrV1_aad_file_unique aesGcmCtrV1_supply_aad_prefix) = Pinch.struct ([ (1 Pinch.?= aesGcmCtrV1_aad_prefix), (2 Pinch.?= aesGcmCtrV1_aad_file_unique), (3 Pinch.?= aesGcmCtrV1_supply_aad_prefix) ])

  unpinch value = (((Prelude.pure (AesGcmCtrV1) Prelude.<*> (value Pinch..:? 1)) Prelude.<*> (value Pinch..:? 2)) Prelude.<*> (value Pinch..:? 3))


instance Data.Hashable.Hashable AesGcmCtrV1 where

data EncryptionAlgorithm
  = EncryptionAlgorithm_AES_GCM_V1 AesGcmV1
  | EncryptionAlgorithm_AES_GCM_CTR_V1 AesGcmCtrV1
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable EncryptionAlgorithm where
  type (Tag EncryptionAlgorithm) = Pinch.TUnion

  pinch (EncryptionAlgorithm_AES_GCM_V1 x) = Pinch.union (1) (x)
  pinch (EncryptionAlgorithm_AES_GCM_CTR_V1 x) = Pinch.union (2) (x)

  unpinch v = ((Control.Applicative.empty Control.Applicative.<|> (EncryptionAlgorithm_AES_GCM_V1 Prelude.<$> (v Pinch..: 1))) Control.Applicative.<|> (EncryptionAlgorithm_AES_GCM_CTR_V1 Prelude.<$> (v Pinch..: 2)))


instance Data.Hashable.Hashable EncryptionAlgorithm where

data FileMetaData
  = FileMetaData { fileMetaData_version :: Data.Int.Int32, fileMetaData_schema :: (Data.Vector.Vector SchemaElement), fileMetaData_num_rows :: Data.Int.Int64, fileMetaData_row_groups :: (Data.Vector.Vector RowGroup), fileMetaData_key_value_metadata :: (Prelude.Maybe (Data.Vector.Vector KeyValue)), fileMetaData_created_by :: (Prelude.Maybe Data.Text.Text), fileMetaData_column_orders :: (Prelude.Maybe (Data.Vector.Vector ColumnOrder)), fileMetaData_encryption_algorithm :: (Prelude.Maybe EncryptionAlgorithm), fileMetaData_footer_signing_key_metadata :: (Prelude.Maybe Data.ByteString.ByteString) }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable FileMetaData where
  type (Tag FileMetaData) = Pinch.TStruct

  pinch (FileMetaData fileMetaData_version fileMetaData_schema fileMetaData_num_rows fileMetaData_row_groups fileMetaData_key_value_metadata fileMetaData_created_by fileMetaData_column_orders fileMetaData_encryption_algorithm fileMetaData_footer_signing_key_metadata) = Pinch.struct ([ (1 Pinch..= fileMetaData_version), (2 Pinch..= fileMetaData_schema), (3 Pinch..= fileMetaData_num_rows), (4 Pinch..= fileMetaData_row_groups), (5 Pinch.?= fileMetaData_key_value_metadata), (6 Pinch.?= fileMetaData_created_by), (7 Pinch.?= fileMetaData_column_orders), (8 Pinch.?= fileMetaData_encryption_algorithm), (9 Pinch.?= fileMetaData_footer_signing_key_metadata) ])

  unpinch value = (((((((((Prelude.pure (FileMetaData) Prelude.<*> (value Pinch..: 1)) Prelude.<*> (value Pinch..: 2)) Prelude.<*> (value Pinch..: 3)) Prelude.<*> (value Pinch..: 4)) Prelude.<*> (value Pinch..:? 5)) Prelude.<*> (value Pinch..:? 6)) Prelude.<*> (value Pinch..:? 7)) Prelude.<*> (value Pinch..:? 8)) Prelude.<*> (value Pinch..:? 9))


instance Data.Hashable.Hashable FileMetaData where

data FileCryptoMetaData
  = FileCryptoMetaData { fileCryptoMetaData_encryption_algorithm :: EncryptionAlgorithm, fileCryptoMetaData_key_metadata :: (Prelude.Maybe Data.ByteString.ByteString) }
  deriving (Prelude.Eq, GHC.Generics.Generic, Prelude.Show)

instance Pinch.Pinchable FileCryptoMetaData where
  type (Tag FileCryptoMetaData) = Pinch.TStruct

  pinch (FileCryptoMetaData fileCryptoMetaData_encryption_algorithm fileCryptoMetaData_key_metadata) = Pinch.struct ([ (1 Pinch..= fileCryptoMetaData_encryption_algorithm), (2 Pinch.?= fileCryptoMetaData_key_metadata) ])

  unpinch value = ((Prelude.pure (FileCryptoMetaData) Prelude.<*> (value Pinch..: 1)) Prelude.<*> (value Pinch..:? 2))


instance Data.Hashable.Hashable FileCryptoMetaData where
